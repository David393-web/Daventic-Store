// src/Redux/slices/authSlice.js
import { createSlice } from '@reduxjs/toolkit';

const authSlice = createSlice({
  name: 'auth', // The name of the slice, used as a key in the Redux store
  initialState: {
    user: null, // Stores user data (e.g., { id, email, name, accountType })
    token: null, // Stores the authentication token (e.g., JWT)
    isAuthenticated: undefined, // âœ… Start as UNDEFINED to indicate 'loading/unknown'
  },
  reducers: {
    /**
     * Reducer to handle user login.
     * Sets the user data, token, and isAuthenticated flag to true.
     * @param {object} state - The current state of the auth slice.
     * @param {object} action - The action object containing payload.
     * Expected payload: { user: { id, email, name, accountType }, token: '...' }
     */
    loginUser: (state, action) => {
      state.user = action.payload.user;
      state.token = action.payload.token;
      state.isAuthenticated = true;
      // redux-persist will automatically save this state if 'auth' slice is whitelisted
    },
    /**
     * Reducer to handle user logout.
     * Clears user data, token, and sets isAuthenticated flag to false.
     * @param {object} state - The current state of the auth slice.
     */
    logoutUser: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      // redux-persist will automatically clear this state if 'auth' slice is whitelisted
    },
    /**
     * Optional reducer to update specific user profile fields without affecting login status.
     * @param {object} state - The current state of the auth slice.
     * @param {object} action - The action object containing partial user data to update.
     * Expected payload: { name: 'New Name', profilePicture: 'url' }
     */
    updateUserProfile: (state, action) => {
        if (state.user) { // Ensure there's a user logged in before updating
            state.user = { ...state.user, ...action.payload };
        }
    },
    /**
     * Action to initialize the session.
     * In conjunction with `redux-persist`, this action's effect often triggers the rehydration
     * of the state from persistent storage when the application starts.
     * The actual state update for rehydration is managed by `redux-persist` middleware,
     * so this reducer itself might not contain explicit logic.
     * When redux-persist rehydrates, it will populate the state.auth with the persisted values,
     * overriding this initial `undefined` or setting it based on stored data.
     * If no data is found, isAuthenticated will typically remain `false` after rehydration.
     */
    initializeSession: (state) => {
      // This reducer is often empty if redux-persist is handling rehydration.
      // The state will be updated by redux-persist when it loads the saved data.
      // If no data is loaded by redux-persist, isAuthenticated might eventually be false (if it's not whitelisted,
      // or if there's no data for it).
      // For now, no explicit logic here, as redux-persist handles the main rehydration.
    }
  },
});

// Export the actions generated by createSlice, which you'll dispatch in your components.
export const { loginUser, logoutUser, updateUserProfile, initializeSession } = authSlice.actions;

// Export the reducer function generated by createSlice.
// This reducer will be combined with other reducers in your Redux store.
export default authSlice.reducer;
